var documenterSearchIndex = {"docs":
[{"location":"#MethodErrorHints.jl","page":"Home","title":"MethodErrorHints.jl","text":"","category":"section"},{"location":"#MethodErrorHints","page":"Home","title":"MethodErrorHints","text":"MethodErrorHints.jl\n\nA Julia package providing a macro to register custom hint messages for MethodErrors.\n\nThis package exports a single macro, @method_error_hint, which allows you to register custom hint messages to be displayed when a MethodError is thrown for a function call.\n\n\n\n\n\n","category":"module"},{"location":"#MethodErrorHints.@method_error_hint","page":"Home","title":"MethodErrorHints.@method_error_hint","text":"@method_error_hint sig msg [key=val...]\n\nRegister a hint message msg to be printed when a MethodError is thrown for a function call matching the signature sig.\n\nThe signature sig is specified in a similar way to a typical method definition in Julia. See below for examples.\n\nAdditional key-value pairs key=val are passed to Base.printstyled when printing the hint message, allowing customization of the appearance of the message. Please see the documentation of Base.printstyled for the available options.\n\nUsage\n\nThis function uses Base.Experimental.register_error_hint, and thus all the suggestions in its docstring are also applicable here.\n\nFor example, this macro should be called within the __init__ function of a module, to ensure that the hint is registered when the module is loaded. Furthermore, since this is an experimental Julia feature, if you wish to guard against breakage you should gate calls to this macro behind if isdefined(Base.Experimental, :register_error_hint).\n\nif isdefined(Base.Experimental, :register_error_hint)\n    function __init__()\n        @method_error_hint f1(x::Int, y; z::String) \"My error hint\" color=:red\n    end\nend\n\nExamples\n\nHere, ✔ indicates an invocation that will trigger the hint, and ✘ indicates one that will not. For the most part, the rules exactly mimic method dispatch in Julia, with some small exceptions noted in the next section.\n\nIn this first example, f1 must be called with two positional arguments and a keyword argument z that have precisely the types specified, plus a keyword argument z. Names of positional arguments are optional as long as a type is specified, but names of keyword arguments are mandatory. If a positional argument is untyped like y here, it is treated as Any.\n\nfunction f1 end\n@method_error_hint f1(x::Int, y; z::String) \"My error hint\" color=:red\n# f1(3,   :a ; z=\"hello\"     ) ✔\n# f1(3,   2  ; z=\"hello\"     ) ✔\n# f1(3,   :a                 ) ✘ (no `z` keyword argument)\n# f1(3.0, :a ; z=\"hello\"     ) ✘ (type of `x` is wrong)\n# f1(3,   :a ; z=1           ) ✘ (type of `z` is wrong)\n# f1(3       ; z=\"hello\"     ) ✘ (missing positional argument `y`)\n# f1(3,   :a ; z=\"hello\", w=1) ✘ (extra keyword argument)\n\nHere, f2 must take a single positional argument of any type, and optionally a keyword argument z. If z is provided, it must be of type Int. The macro does not actually use the default value specified for the keyword argument; you can use undef to avoid specifying one.\n\nfunction f2 end\n@method_error_hint f2(x; z::Int=3) \"Another error hint\" bold=true\n# f2(3                )  ✔\n# f2(3     ; z=2      )  ✔\n# f2(3     ; z=\"hello\")  ✘ (type of `z` is wrong)\n# f2(3, :a            )  ✘ (extra positional argument)\n# f2(3, :a ; z=2      )  ✘ (extra positional argument)\n\nVariable-length positional and keyword arguments are supported.\n\nfunction f3 end\n@method_error_hint f3(args...; kwargs...) \"Another hint\" italic=true\n# Any invocation of `f3` will trigger this.\n\nKnown limitations\n\nVararg annotations on splatted positional arguments are not supported. This will probably be fixed in a future version.\nType parameters and where-clauses are not supported, for example f(x::T, y::T) where {T}. If you need this functionality, you should consider crafting your own error hint (for this particular signature, following the example in the docstring of Base.Experimental.register_error_hint, you could check that length(argtypes) == 2 && argtypes[1] == argtypes[2]). Support for type parameters will probably never be implemented in this package.\n\nExtended help\n\nBehind the scenes\n\nThis macro's only real job is to parse the method signature, and then generate a call to Base.Experimental.register_error_hint that checks that the method the user tried to invoke matches the signature. This is best illustrated by an example. This:\n\nfunction f1 end\n@method_error_hint f1(x::Int, y; z::String) \"My error hint\" color=:red\n\nexpands into something like this:\n\nBase.Experimental.register_error_hint(MethodError) do io, exc, argtypes, kwargs\n    # This Dict is parsed from the method signature passed to the macro, i.e., this is the\n    # 'target' signature we are trying to match.\n    target_kwargtypes = Dict{Symbol,Any}(:z => String)\n    # This Vector is also parsed from the method signature, and indicates which keyword\n    # arguments are mandatory (i.e., have no default value in the method signature).\n    mandatory_kwargs = [:z]\n    # This one indicates whether the method signature has `kwargs...`.\n    has_varkwargs = false\n    # Extract the actual symbols of the keyword arguments passed in the invocation\n    kwarg_symbols = __kwargs_symbols(kwargs)\n    if (\n        # Check that the function name is correct\n        exc.f === f1\n        # Check that number of positional arguments is correct\n        && length(argtypes) == 2\n        # Check that types of positional arguments are correct\n        && argtypes[1] <: Int\n        && argtypes[2] <: Any\n        # Check that any mandatory keyword arguments are present (i.e., if there is no\n        # default value in the method signature, it must be present in the invocation)\n        && haskey(kwarg_symbols, :z)\n        # Check that no unexpected keyword arguments are present (i.e., any keyword argument\n        # in the invocation must either be specified in the method signature and obey the\n        # type specified in the signature, or the method signature must have `kwargs...`).\n        && all(collect(kwargs)) do (sym, typ)\n            if haskey(target_kwargtypes, sym)\n                # On Julia <= 1.10 we get values instead of types so we have to use `isa`\n                # instead of `<:`\n                typ <: target_kwargtypes[sym]\n            else\n                has_varkwargs\n            end\n        end\n    )\n        printstyled(io, \"My error hint\"; :color=:red)\n    end\nend\n\nIf you would like to see this in more detail, please refer to the source code of this package.\n\n\n\n\n\n","category":"macro"}]
}
